var A=Object.defineProperty;var E=Object.getOwnPropertySymbols;var D=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable;var f=Math.pow,b=(l,t,i)=>t in l?A(l,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):l[t]=i,m=(l,t)=>{for(var i in t||(t={}))D.call(t,i)&&b(l,i,t[i]);if(E)for(var i of E(t))k.call(t,i)&&b(l,i,t[i]);return l};var o=(l,t,i)=>(b(l,typeof t!="symbol"?t+"":t,i),i);var M=(l,t,i)=>new Promise((e,s)=>{var n=a=>{try{c(i.next(a))}catch(h){s(h)}},r=a=>{try{c(i.throw(a))}catch(h){s(h)}},c=a=>a.done?e(a.value):Promise.resolve(a.value).then(n,r);c((i=i.apply(l,t)).next())});(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))e(s);new MutationObserver(s=>{for(const n of s)if(n.type==="childList")for(const r of n.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&e(r)}).observe(document,{childList:!0,subtree:!0});function i(s){const n={};return s.integrity&&(n.integrity=s.integrity),s.referrerPolicy&&(n.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?n.credentials="include":s.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function e(s){if(s.ep)return;s.ep=!0;const n=i(s);fetch(s.href,n)}})();var S=(l=>(l.MENU="menu",l.PLAYING="playing",l.PAUSED="paused",l.LEVEL_COMPLETE="level_complete",l.GAME_OVER="game_over",l.LOADING="loading",l))(S||{});class O{constructor(){o(this,"currentState","menu");o(this,"stateData",{currentLevel:1,score:0,lives:3,isPaused:!1,isGameOver:!1});console.log("📊 GameState initialized")}getCurrentState(){return this.currentState}setState(t){const i=this.currentState;this.currentState=t,console.log(`🔄 Game state changed: ${i} → ${t}`)}getStateData(){return m({},this.stateData)}updateStateData(t){this.stateData=m(m({},this.stateData),t)}isState(t){return this.currentState===t}isPlaying(){return this.currentState==="playing"}isPaused(){return this.currentState==="paused"}isGameOver(){return this.currentState==="game_over"}reset(){this.currentState="menu",this.stateData={currentLevel:1,score:0,lives:3,isPaused:!1,isGameOver:!1},console.log("🔄 Game state reset")}}class G{constructor(){o(this,"animationId",null);o(this,"lastTime",0);o(this,"accumulator",0);o(this,"timestep",1e3/60);o(this,"isRunning",!1);o(this,"isPaused",!1);o(this,"renderer",null);o(this,"physicsEngine",null);o(this,"game",null);console.log("🔄 GameLoop initialized")}start(t,i,e,s){if(this.isRunning){console.warn("⚠️ Game loop is already running");return}this.renderer=i||null,this.physicsEngine=e||null,this.game=s||null,this.isRunning=!0,this.isPaused=!1,this.lastTime=performance.now(),this.accumulator=0,console.log("▶️ Game loop started"),this.gameLoop(t)}gameLoop(t){if(!this.isRunning)return;const i=performance.now(),e=i-this.lastTime;for(this.lastTime=i,this.accumulator+=e;this.accumulator>=this.timestep;)this.isPaused||this.update(t,this.timestep),this.accumulator-=this.timestep;this.render(t),this.animationId=requestAnimationFrame(()=>this.gameLoop(t))}update(t,i){this.game&&this.game.update&&this.game.update(i),this.physicsEngine&&this.physicsEngine.update(i)}render(t){this.renderer&&(this.renderer.clear(),t.isPlaying()?this.renderGameplay():t.isState(S.MENU)?this.renderMenu():t.isState(S.PAUSED)&&this.renderPaused())}renderGameplay(){if(!this.renderer)return;const t=this.renderer.getContext();if(t){if(t.fillStyle="#1a1a1a",t.fillRect(0,0,360,640),this.physicsEngine){for(const i of this.physicsEngine.getObjects()){t.beginPath();const e=i.position||{x:i.x||0,y:i.y||0},s=i.radius||10;t.arc(e.x,e.y,s,0,Math.PI*2),i.isStatic?(t.fillStyle="#ff0066",t.shadowColor="#ff0066"):(t.fillStyle="#00ffff",t.shadowColor="#00ffff"),t.shadowBlur=16,t.fill(),t.shadowBlur=0,t.closePath(),this.physicsEngine.getDebug&&this.physicsEngine.getDebug()&&(!i.isStatic&&i.velocity&&(t.beginPath(),t.moveTo(e.x,e.y),t.lineTo(e.x+i.velocity.x*3,e.y+i.velocity.y*3),t.strokeStyle="#ffff00",t.lineWidth=1,t.stroke(),t.closePath()),t.fillStyle="#ffffff",t.font="8px Courier New",t.textAlign="center",t.fillText(i.id,e.x,e.y-s-5))}if(this.physicsEngine.getDebug&&this.physicsEngine.getDebug()){if(this.physicsEngine.getCollisionManifolds){const i=this.physicsEngine.getCollisionManifolds();for(const e of i)t.beginPath(),t.arc(e.contactPoint.x,e.contactPoint.y,2,0,Math.PI*2),t.fillStyle="#ff0000",t.fill(),t.closePath()}if(this.physicsEngine.getConstraints){const i=this.physicsEngine.getConstraints();for(const e of i)e.type==="distance"&&e.objectB&&(t.beginPath(),t.moveTo(e.objectA.position.x,e.objectA.position.y),t.lineTo(e.objectB.position.x,e.objectB.position.y),t.strokeStyle="#00ff00",t.lineWidth=1,t.setLineDash([3,3]),t.stroke(),t.setLineDash([]),t.closePath())}}}if(t.fillStyle="#00ffff",t.font="20px Courier New",t.textAlign="center",t.fillText("Circuit Breaker",180,40),t.font="12px Courier New",t.fillText("Robust Physics System Active",180,60),this.game&&this.game.renderGameplay&&this.game.renderGameplay(),this.physicsEngine){const i=this.physicsEngine.getObjects(),e=i.filter(n=>!n.isStatic).length,s=i.filter(n=>n.isStatic).length;if(t.font="10px Courier New",t.textAlign="left",t.fillStyle="#00ffff",t.fillText(`Objects: ${e} dynamic, ${s} static`,10,610),t.fillText(`Gravity: ${this.physicsEngine.getGravity()}`,10,625),this.physicsEngine.getCollisionManifolds){const n=this.physicsEngine.getCollisionManifolds().length;t.fillText(`Collisions: ${n}`,200,610)}t.fillText("Physics: Optimized Verlet (1 substep)",10,595)}}}renderMenu(){if(!this.renderer)return;const t=this.renderer.getContext();t&&(t.fillStyle="#1a1a1a",t.fillRect(0,0,360,640),t.fillStyle="#00ffff",t.font="24px Courier New",t.textAlign="center",t.fillText("CIRCUIT BREAKER",180,280),t.font="14px Courier New",t.fillText("Neon Cyberpunk Arcade Game",180,310),t.font="12px Courier New",t.fillText("Click to Start",180,350))}renderPaused(){if(!this.renderer)return;const t=this.renderer.getContext();t&&(t.fillStyle="rgba(0, 0, 0, 0.7)",t.fillRect(0,0,360,640),t.fillStyle="#00ffff",t.font="20px Courier New",t.textAlign="center",t.fillText("PAUSED",180,320))}pause(){this.isPaused=!0,console.log("⏸️ Game loop paused")}resume(){this.isPaused=!1,console.log("▶️ Game loop resumed")}stop(){this.isRunning=!1,this.animationId!==null&&(cancelAnimationFrame(this.animationId),this.animationId=null),console.log("⏹️ Game loop stopped")}isGameLoopRunning(){return this.isRunning}isGameLoopPaused(){return this.isPaused}getFPS(){return 1e3/this.timestep}}class u{static setEnabled(t){this.isEnabled=t}static log(t,...i){if(!this.isEnabled)return;const s=`[${new Date().toISOString()}] ${t}`;console.log(s,...i),this.addToLogs(s)}static warn(t,...i){if(!this.isEnabled)return;const s=`[${new Date().toISOString()}] WARNING: ${t}`;console.warn(s,...i),this.addToLogs(s)}static error(t,...i){if(!this.isEnabled)return;const s=`[${new Date().toISOString()}] ERROR: ${t}`;console.error(s,...i),this.addToLogs(s)}static addToLogs(t){this.logs.push(t),this.logs.length>this.maxLogs&&this.logs.shift()}static getLogs(){return[...this.logs]}static clearLogs(){this.logs=[]}static measurePerformance(t,i){if(!this.isEnabled)return i();const e=performance.now(),s=i(),n=performance.now();return this.log(`Performance [${t}]: ${(n-e).toFixed(2)}ms`),s}static createTimer(t){const i=performance.now();return()=>{const e=performance.now();this.log(`Timer [${t}]: ${(e-i).toFixed(2)}ms`)}}static assert(t,i){if(this.isEnabled&&!t)throw this.error(`Assertion failed: ${i}`),new Error(`Assertion failed: ${i}`)}static getMemoryInfo(){return this.isEnabled?{logsCount:this.logs.length,timestamp:new Date().toISOString()}:{}}static exportDebugInfo(){return{enabled:this.isEnabled,logs:this.getLogs(),memory:this.getMemoryInfo()}}}o(u,"isEnabled",!0),o(u,"logs",[]),o(u,"maxLogs",100);class B{constructor(){o(this,"canvas",null);o(this,"ctx",null);o(this,"width",800);o(this,"height",600);u.log("🎨 Renderer initialized")}init(t){if(this.canvas=t,this.ctx=t.getContext("2d"),!this.ctx)throw new Error("Failed to get 2D context from canvas");this.width=t.width,this.height=t.height,u.log(`Renderer initialized with canvas: ${this.width}x${this.height}`)}clear(){this.ctx&&this.ctx.clearRect(0,0,this.width,this.height)}render(){this.ctx}drawTiltingBar(t){if(!this.ctx)return;const i=t.getEndpoints();this.ctx.save(),this.ctx.shadowColor=t.glowColor,this.ctx.shadowBlur=20,this.ctx.lineWidth=t.thickness+4,this.ctx.strokeStyle=t.glowColor,this.ctx.globalAlpha=.3,this.ctx.beginPath(),this.ctx.moveTo(i.start.x,i.start.y),this.ctx.lineTo(i.end.x,i.end.y),this.ctx.stroke(),this.ctx.shadowBlur=0,this.ctx.globalAlpha=1,this.ctx.lineWidth=t.thickness,this.ctx.strokeStyle=t.color,this.ctx.beginPath(),this.ctx.moveTo(i.start.x,i.start.y),this.ctx.lineTo(i.end.x,i.end.y),this.ctx.stroke(),this.ctx.fillStyle=t.color,this.ctx.beginPath(),this.ctx.arc(t.position.x,t.position.y,6,0,Math.PI*2),this.ctx.fill(),this.ctx.fillStyle="rgba(0, 255, 255, 0.7)",this.ctx.font="12px monospace",this.ctx.textAlign="center";const e=640-t.leftSideHeight;this.ctx.fillText(`L: ${e.toFixed(0)}`,t.position.x-t.width/4,Math.min(t.leftSideHeight,t.rightSideHeight)-25);const s=640-t.rightSideHeight;this.ctx.fillText(`R: ${s.toFixed(0)}`,t.position.x+t.width/4,Math.min(t.leftSideHeight,t.rightSideHeight)-25);const n=t.getTiltPercentage();this.ctx.fillText(`Tilt: ${(n*100).toFixed(0)}%`,t.position.x,Math.min(t.leftSideHeight,t.rightSideHeight)-40),this.ctx.restore()}getContext(){return this.ctx}getDimensions(){return{width:this.width,height:this.height}}resize(t,i){this.canvas&&(this.width=t,this.height=i,this.canvas.width=t,this.canvas.height=i,u.log(`Renderer resized to: ${t}x${i}`))}}class ${constructor(){o(this,"gravity",{x:0,y:400});o(this,"airResistance",.999);o(this,"objects",[]);o(this,"constraints",[]);o(this,"spatialGrid",new Map);o(this,"gridSize",60);o(this,"tiltingBar",null);o(this,"bounds",{width:360,height:640});o(this,"deltaTime",1/60);o(this,"debug",!1);o(this,"collisionManifolds",[]);u.log("⚡ Advanced PhysicsEngine initialized with Verlet integration")}setTiltingBar(t){this.tiltingBar=t}createObject(t){const i=t.mass||1;return{id:t.id,position:{x:t.x,y:t.y},previousPosition:{x:t.x,y:t.y},acceleration:{x:0,y:0},velocity:{x:0,y:0},radius:t.radius,mass:i,inverseMass:t.isStatic?0:1/i,restitution:t.restitution||.7,friction:t.friction||.3,isStatic:t.isStatic||!1,constraints:[],x:t.x,y:t.y,vx:0,vy:0}}addObject(t){var i,e;t.previousPosition||(t.previousPosition={x:((i=t.position)==null?void 0:i.x)||t.x||0,y:((e=t.position)==null?void 0:e.y)||t.y||0}),t.acceleration||(t.acceleration={x:0,y:0}),t.velocity||(t.velocity={x:0,y:0}),t.inverseMass||(t.inverseMass=t.isStatic?0:1/(t.mass||1)),t.constraints||(t.constraints=[]),this.objects.push(t),this.updateSpatialGrid(),u.log(`Added physics object: ${t.id}`)}removeObject(t){this.objects=this.objects.filter(i=>i.id!==t),this.updateSpatialGrid(),u.log(`Removed physics object: ${t}`)}addConstraint(t){this.constraints.push(t),u.log(`Added constraint: ${t.type}`)}update(t){const i=Math.min(t,.03333333333333333);this.simulateStep(i),this.updateBackwardCompatibility()}simulateStep(t){this.collisionManifolds=[];for(const i of this.objects)i.isRollingOnBar=!1;this.objects.length>0&&this.updateSpatialGrid(),this.integratePositions(t),this.solveConstraints(),this.detectAndResolveCollisions(),this.handleTiltingBarCollisions(),this.handleBoundaryCollisions(),this.updateVelocities(t)}integratePositions(t){for(const i of this.objects){if(i.isStatic)continue;const e=i.position.x-i.previousPosition.x,s=i.position.y-i.previousPosition.y;i.previousPosition.x=i.position.x,i.previousPosition.y=i.position.y,i.position.x+=e*this.airResistance+this.gravity.x*t*t,i.position.y+=s*this.airResistance+this.gravity.y*t*t}}updateVelocities(t){for(const i of this.objects)i.isStatic||(i.velocity.x=(i.position.x-i.previousPosition.x)/t,i.velocity.y=(i.position.y-i.previousPosition.y)/t)}solveConstraints(){for(const t of this.constraints)this.solveConstraint(t)}solveConstraint(t){switch(t.type){case"distance":this.solveDistanceConstraint(t);break;case"position":this.solvePositionConstraint(t);break;case"angle":this.solveAngleConstraint(t);break}}solveDistanceConstraint(t){if(!t.objectB||!t.targetDistance)return;const i=t.objectA,e=t.objectB,s=e.position.x-i.position.x,n=e.position.y-i.position.y,r=Math.sqrt(s*s+n*n);if(r===0)return;const a=(t.targetDistance-r)/r/2,h=s*a*t.stiffness,g=n*a*t.stiffness;i.isStatic||(i.position.x-=h*i.inverseMass,i.position.y-=g*i.inverseMass),e.isStatic||(e.position.x+=h*e.inverseMass,e.position.y+=g*e.inverseMass)}solvePositionConstraint(t){if(!t.targetPosition)return;const i=t.objectA;if(i.isStatic)return;const e=t.targetPosition.x-i.position.x,s=t.targetPosition.y-i.position.y;i.position.x+=e*t.stiffness,i.position.y+=s*t.stiffness}solveAngleConstraint(t){}detectAndResolveCollisions(){if(!(this.objects.length<2))for(let t=0;t<this.objects.length;t++){const i=this.objects[t];if(!i.isStatic)for(let e=t+1;e<this.objects.length;e++){const s=this.objects[e],n=s.position.x-i.position.x,r=s.position.y-i.position.y,c=i.radius+s.radius+5;if(n*n+r*r<c*c){const a=this.detectCollision(i,s);a&&(this.collisionManifolds.push(a),this.resolveCollisionSimple(a))}}}}detectCollision(t,i){const e=i.position.x-t.position.x,s=i.position.y-t.position.y,n=Math.sqrt(e*e+s*s),r=t.radius+i.radius;if(n<r){const c=r-n,a=n>0?{x:e/n,y:s/n}:{x:1,y:0};return{objectA:t,objectB:i,normal:a,penetration:c,contactPoint:{x:t.position.x+a.x*t.radius,y:t.position.y+a.y*t.radius}}}return null}resolveCollision(t){const i=t.objectA,e=t.objectB,s=t.penetration/(i.inverseMass+e.inverseMass)*.8;i.position.x-=t.normal.x*s*i.inverseMass,i.position.y-=t.normal.y*s*i.inverseMass,e.position.x+=t.normal.x*s*e.inverseMass,e.position.y+=t.normal.y*s*e.inverseMass;const n={x:e.velocity.x-i.velocity.x,y:e.velocity.y-i.velocity.y},r=n.x*t.normal.x+n.y*t.normal.y;if(r>0)return;const a=-(1+Math.min(i.restitution,e.restitution))*r/(i.inverseMass+e.inverseMass),h={x:a*t.normal.x,y:a*t.normal.y};i.isStatic||(i.previousPosition.x-=h.x*i.inverseMass,i.previousPosition.y-=h.y*i.inverseMass),e.isStatic||(e.previousPosition.x+=h.x*e.inverseMass,e.previousPosition.y+=h.y*e.inverseMass)}resolveCollisionSimple(t){const i=t.objectA,e=t.objectB,s=t.normal.x*t.penetration*.5,n=t.normal.y*t.penetration*.5;i.isStatic||(i.position.x-=s,i.position.y-=n),e.isStatic||(e.position.x+=s,e.position.y+=n);const r={x:e.velocity.x-i.velocity.x,y:e.velocity.y-i.velocity.y},c=r.x*t.normal.x+r.y*t.normal.y;if(c>0)return;const a=Math.min(i.restitution,e.restitution)*.8,h=c*a;i.isStatic||(i.previousPosition.x+=t.normal.x*h*.5,i.previousPosition.y+=t.normal.y*h*.5),e.isStatic||(e.previousPosition.x-=t.normal.x*h*.5,e.previousPosition.y-=t.normal.y*h*.5)}handleTiltingBarCollisions(){if(this.tiltingBar)for(const t of this.objects){if(t.isStatic)continue;const i=this.tiltingBar.getEndpoints(),e=this.getClosestPointOnLineSegment(t.position,i.start,i.end),s=Math.sqrt(f(t.position.x-e.x,2)+f(t.position.y-e.y,2)),r=(this.tiltingBar.thickness||12)/2,c=t.radius+r;if(s<c){const a={x:i.end.x-i.start.x,y:i.end.y-i.start.y},h=Math.sqrt(a.x*a.x+a.y*a.y),g={x:a.x/h,y:a.y/h},d={x:-a.y/h,y:a.x/h};d.y>0&&(d.x=-d.x,d.y=-d.y);const x={x:e.x+d.x*r,y:e.y+d.y*r};t.position.x=x.x+d.x*t.radius,t.position.y=x.y+d.y*t.radius;const y={x:t.position.x-t.previousPosition.x,y:t.position.y-t.previousPosition.y},P=y.x*d.x+y.y*d.y,R=y.x*g.x+y.y*g.y;if(P<-.5){const w=t.restitution*.8,T=this.tiltingBar.friction||.3,v={x:y.x-2*P*d.x,y:y.y-2*P*d.y};v.x*=w*(1-T),v.y*=w,t.previousPosition.x=t.position.x-v.x,t.previousPosition.y=t.position.y-v.y}else this.applyRollingPhysics(t,g,d,R,this.deltaTime)}}}applyRollingPhysics(t,i,e,s,n){const r=this.gravity.x*i.x+this.gravity.y*i.y,c=this.tiltingBar.friction||.05,a=.01;let h=r;if(Math.abs(s)>.5){const x=-Math.sign(s)*a*Math.abs(this.gravity.y);h+=x}if(Math.abs(s)>.5){const x=-Math.sign(s)*c*Math.abs(this.gravity.y);h+=x}const g=s+h*n,d={x:g*i.x,y:g*i.y};t.previousPosition.x=t.position.x-d.x,t.previousPosition.y=t.position.y-d.y,t.velocity.x=d.x,t.velocity.y=d.y,t.isRollingOnBar=!0}isBallOnBar(t){const i=this.objects.find(a=>a.id===t);if(!i||!this.tiltingBar)return!1;const e=this.tiltingBar.getEndpoints(),s=this.getClosestPointOnLineSegment(i.position,e.start,e.end),n=Math.sqrt(f(i.position.x-s.x,2)+f(i.position.y-s.y,2)),r=this.tiltingBar.thickness||12,c=i.radius+r/2;return n<=c+2}handleBoundaryCollisions(){for(const t of this.objects)if(!t.isStatic){if(t.position.y+t.radius>this.bounds.height){t.position.y=this.bounds.height-t.radius;const i={x:t.position.x-t.previousPosition.x,y:t.position.y-t.previousPosition.y};i.y>0&&(t.previousPosition.y=t.position.y+i.y*t.restitution,t.previousPosition.x=t.position.x-i.x*.8)}if(t.position.x-t.radius<0){t.position.x=t.radius;const i={x:t.position.x-t.previousPosition.x,y:t.position.y-t.previousPosition.y};i.x<0&&(t.previousPosition.x=t.position.x+i.x*t.restitution)}else if(t.position.x+t.radius>this.bounds.width){t.position.x=this.bounds.width-t.radius;const i={x:t.position.x-t.previousPosition.x,y:t.position.y-t.previousPosition.y};i.x>0&&(t.previousPosition.x=t.position.x+i.x*t.restitution)}}}updateBackwardCompatibility(){for(const t of this.objects)t.x=t.position.x,t.y=t.position.y,t.vx=t.velocity.x,t.vy=t.velocity.y}updateSpatialGrid(){if(!(this.objects.length<=3)){this.spatialGrid.clear();for(const t of this.objects){const i=this.getObjectCells(t);for(const e of i)this.spatialGrid.has(e)||this.spatialGrid.set(e,{objects:[]}),this.spatialGrid.get(e).objects.push(t)}}}getObjectCells(t){const i=[],e=t.radius,s=Math.floor((t.position.x-e)/this.gridSize),n=Math.floor((t.position.x+e)/this.gridSize),r=Math.floor((t.position.y-e)/this.gridSize),c=Math.floor((t.position.y+e)/this.gridSize);for(let a=s;a<=n;a++)for(let h=r;h<=c;h++)i.push(`${a},${h}`);return i}getNearbyObjects(t){const i=[],e=this.getObjectCells(t);for(const s of e){const n=this.spatialGrid.get(s);if(n)for(const r of n.objects)r.id!==t.id&&!i.includes(r)&&i.push(r)}return i}getClosestPointOnLineSegment(t,i,e){const s=e.x-i.x,n=e.y-i.y,r=Math.sqrt(s*s+n*n);if(r===0)return i;const c=Math.max(0,Math.min(1,((t.x-i.x)*s+(t.y-i.y)*n)/(r*r)));return{x:i.x+c*s,y:i.y+c*n}}getObjects(){return this.objects}setGravity(t,i){this.gravity.x=t,this.gravity.y=i,u.log(`Gravity set to: (${t}, ${i})`)}setAirResistance(t){this.airResistance=Math.max(0,Math.min(1,t)),u.log(`Air resistance set to: ${this.airResistance}`)}setBounds(t,i){this.bounds.width=t,this.bounds.height=i,u.log(`Physics bounds set to: ${t}x${i}`)}setDebug(t){this.debug=t}getDebug(){return this.debug}getCollisionManifolds(){return this.collisionManifolds}getConstraints(){return this.constraints}getFriction(){return .98}getBounceEnergy(){return .7}getGravity(){return this.gravity.y}setFriction(t){u.log("Legacy friction setting ignored - use per-object friction instead")}setBounceEnergy(t){u.log("Legacy bounce energy setting ignored - use per-object restitution instead")}}class j{constructor(t){o(this,"position");o(this,"rotation",0);o(this,"targetRotation",0);o(this,"leftSideHeight",590);o(this,"rightSideHeight",590);o(this,"minSideHeight",50);o(this,"maxSideHeight",590);o(this,"sideSpeed",100);o(this,"width");o(this,"height");o(this,"maxRotation");o(this,"rotationSpeed");o(this,"friction");o(this,"color","#00ffff");o(this,"glowColor","#0088ff");o(this,"thickness",12);this.position=m({},t.position),this.width=t.width,this.height=t.height,this.maxRotation=t.maxRotation,this.rotationSpeed=t.rotationSpeed,this.friction=t.friction}setTargetRotation(t){this.targetRotation=Math.max(-this.maxRotation,Math.min(this.maxRotation,t))}moveLeftSide(t){t!==0&&(this.leftSideHeight-=t*this.sideSpeed*(1/60),this.leftSideHeight=Math.max(this.minSideHeight,Math.min(this.maxSideHeight,this.leftSideHeight)))}moveRightSide(t){t!==0&&(this.rightSideHeight-=t*this.sideSpeed*(1/60),this.rightSideHeight=Math.max(this.minSideHeight,Math.min(this.maxSideHeight,this.rightSideHeight)))}getTiltPercentage(){return this.rotation/this.maxRotation}update(t){const i=this.rightSideHeight-this.leftSideHeight,e=this.maxSideHeight-this.minSideHeight;this.rotation=i/e*this.maxRotation,this.targetRotation=this.rotation}getEndpoints(){const t=this.width/2;return{start:{x:this.position.x-t,y:this.leftSideHeight},end:{x:this.position.x+t,y:this.rightSideHeight}}}getNormal(){const t=this.getEndpoints(),i=t.end.x-t.start.x,e=t.end.y-t.start.y,s=Math.sqrt(i*i+e*e);return s===0?{x:0,y:-1}:{x:-e/s,y:i/s}}isPointNearBar(t,i){const e=this.getEndpoints(),s=this.distanceToLineSegment(t,e.start,e.end),n=i+this.thickness/2+2;return s<=n}distanceToLineSegment(t,i,e){const s=e.x-i.x,n=e.y-i.y,r=Math.sqrt(s*s+n*n);if(r===0)return Math.sqrt(f(t.x-i.x,2)+f(t.y-i.y,2));const c=Math.max(0,Math.min(1,((t.x-i.x)*s+(t.y-i.y)*n)/(r*r))),a={x:i.x+c*s,y:i.y+c*n};return Math.sqrt(f(t.x-a.x,2)+f(t.y-a.y,2))}getCollisionResponse(t,i,e){const s=this.getEndpoints(),n=this.getNormal(),r=this.distanceToLineSegment(t,s.start,s.end),c=e+this.thickness/2-r,a={x:t.x+n.x*c,y:t.y+n.y*c},h=i.x*n.x+i.y*n.y;let g=i;if(h<0){const d={x:i.x-2*h*n.x,y:i.y-2*h*n.y},x=1-this.friction,y=.8;g={x:d.x*x*y,y:d.y*y}}return{velocity:g,position:a}}}class I{constructor(){o(this,"inputState",{keys:{},mouse:{x:0,y:0,isDown:!1,button:-1},tiltInput:0});o(this,"previousKeys",{});o(this,"canvas",null);o(this,"keyBindings",{leftSideUp:["KeyA"],leftSideDown:["KeyZ"],rightSideUp:["ArrowUp"],rightSideDown:["ArrowDown"],start:["Space"],reset:["KeyR"],pause:["KeyP","Escape"]});this.setupEventListeners()}init(t){this.canvas=t,this.setupCanvasListeners()}getInputState(){return m({},this.inputState)}getTiltInput(){return this.inputState.tiltInput}getLeftSideInput(){let t=0;return this.isActionPressed("leftSideUp")&&(t=1),this.isActionPressed("leftSideDown")&&(t=-1),t}getRightSideInput(){let t=0;return this.isActionPressed("rightSideUp")&&(t=1),this.isActionPressed("rightSideDown")&&(t=-1),t}isActionPressed(t){return this.keyBindings[t].some(i=>this.inputState.keys[i])}isActionJustPressed(t){const i=this.keyBindings[t].some(e=>this.inputState.keys[e]&&!this.previousKeys[e]);return t==="start"&&i&&console.log("🔑 Start key (SPACE) just pressed!"),i}update(){let t=0,i=0;this.isActionPressed("leftSideUp")&&(t=1),this.isActionPressed("leftSideDown")&&(t=-1),this.isActionPressed("rightSideUp")&&(i=1),this.isActionPressed("rightSideDown")&&(i=-1);const e=(i-t)*.5;if(this.canvas&&this.inputState.mouse.isDown){const s=this.canvas.getBoundingClientRect(),n=s.width/2,c=(this.inputState.mouse.x-s.left-n)/n;this.inputState.tiltInput=Math.max(-1,Math.min(1,c))}else this.inputState.tiltInput=Math.max(-1,Math.min(1,e))}endFrame(){this.previousKeys=m({},this.inputState.keys)}setupEventListeners(){document.addEventListener("keydown",this.handleKeyDown.bind(this)),document.addEventListener("keyup",this.handleKeyUp.bind(this)),document.addEventListener("keydown",t=>{Object.values(this.keyBindings).flat().includes(t.code)&&t.preventDefault()})}setupCanvasListeners(){this.canvas&&(this.canvas.addEventListener("mousedown",this.handleMouseDown.bind(this)),this.canvas.addEventListener("mouseup",this.handleMouseUp.bind(this)),this.canvas.addEventListener("mousemove",this.handleMouseMove.bind(this)),this.canvas.addEventListener("mouseleave",this.handleMouseLeave.bind(this)),this.canvas.addEventListener("touchstart",this.handleTouchStart.bind(this)),this.canvas.addEventListener("touchend",this.handleTouchEnd.bind(this)),this.canvas.addEventListener("touchmove",this.handleTouchMove.bind(this)))}handleKeyDown(t){this.inputState.keys[t.code]=!0}handleKeyUp(t){this.inputState.keys[t.code]=!1}handleMouseDown(t){this.inputState.mouse.isDown=!0,this.inputState.mouse.button=t.button,this.updateMousePosition(t)}handleMouseUp(t){this.inputState.mouse.isDown=!1,this.inputState.mouse.button=-1}handleMouseMove(t){this.updateMousePosition(t)}handleMouseLeave(){this.inputState.mouse.isDown=!1,this.inputState.mouse.button=-1}handleTouchStart(t){t.preventDefault(),t.touches.length>0&&(this.inputState.mouse.isDown=!0,this.updateTouchPosition(t.touches[0]))}handleTouchEnd(t){t.preventDefault(),this.inputState.mouse.isDown=!1}handleTouchMove(t){t.preventDefault(),t.touches.length>0&&this.updateTouchPosition(t.touches[0])}updateMousePosition(t){this.inputState.mouse.x=t.clientX,this.inputState.mouse.y=t.clientY}updateTouchPosition(t){this.inputState.mouse.x=t.clientX,this.inputState.mouse.y=t.clientY}dispose(){document.removeEventListener("keydown",this.handleKeyDown.bind(this)),document.removeEventListener("keyup",this.handleKeyUp.bind(this)),this.canvas&&(this.canvas.removeEventListener("mousedown",this.handleMouseDown.bind(this)),this.canvas.removeEventListener("mouseup",this.handleMouseUp.bind(this)),this.canvas.removeEventListener("mousemove",this.handleMouseMove.bind(this)),this.canvas.removeEventListener("mouseleave",this.handleMouseLeave.bind(this)),this.canvas.removeEventListener("touchstart",this.handleTouchStart.bind(this)),this.canvas.removeEventListener("touchend",this.handleTouchEnd.bind(this)),this.canvas.removeEventListener("touchmove",this.handleTouchMove.bind(this)))}}class H{constructor(){o(this,"gameState");o(this,"gameLoop");o(this,"renderer");o(this,"physicsEngine");o(this,"inputManager");o(this,"tiltingBar");o(this,"isRunning",!1);this.gameState=new O,this.gameLoop=new G,this.renderer=new B,this.physicsEngine=new $,this.inputManager=new I,this.tiltingBar=new j({position:{x:180,y:590},width:360,height:8,maxRotation:Math.PI/4,rotationSpeed:3,friction:.05}),console.log("🎮 Circuit Breaker - Game initialized")}init(){return M(this,null,function*(){try{console.log("🚀 Initializing Circuit Breaker...");const t=document.getElementById("game-canvas");if(!t)throw new Error("Canvas element not found");this.renderer.init(t),this.physicsEngine.setGravity(0,400),this.physicsEngine.setAirResistance(.999),this.physicsEngine.setBounds(360,640),this.physicsEngine.setTiltingBar(this.tiltingBar),this.inputManager.init(t);const i=12,e=-50,s=300,n=this.physicsEngine.createObject({id:"game-ball",x:e,y:s,radius:i,mass:1,restitution:.8,friction:.2,isStatic:!1});this.physicsEngine.addObject(n),this.physicsEngine.setDebug(!1),this.isRunning=!0,console.log("✅ Circuit Breaker initialized successfully")}catch(t){throw console.error("❌ Failed to initialize Circuit Breaker:",t),t}})}start(){if(!this.isRunning){console.warn("⚠️ Game not initialized. Call init() first.");return}console.log("▶️ Starting Circuit Breaker..."),this.gameState.setState(S.PLAYING),this.gameLoop.start(this.gameState,this.renderer,this.physicsEngine,this)}update(t){this.inputManager.update(),this.inputManager.isActionJustPressed("start")&&(console.log("🎯 SPACE pressed - placing ball on bar"),this.placeBallOnBar());const i=this.inputManager.getLeftSideInput(),e=this.inputManager.getRightSideInput();this.tiltingBar.moveLeftSide(i),this.tiltingBar.moveRightSide(e),this.tiltingBar.update(t/1e3),this.inputManager.endFrame()}placeBallOnBar(){const t=this.physicsEngine.getObjects().find(i=>i.id==="game-ball");if(t){const i=t.radius,e=360-i-5,s=this.tiltingBar.rightSideHeight,n=this.tiltingBar.thickness,r=s-n/2,c=r-10-i;console.log("🏀 Precise ball placement:"),console.log(`   Ball radius: ${i}`),console.log(`   Bar right side Y: ${s}`),console.log(`   Bar thickness: ${n}`),console.log(`   Bar top surface: ${r}`),console.log(`   Ball center Y: ${c}`),console.log(`   Ball bottom Y: ${c+i} (should be ${r-10})`),console.log(`   Gap between ball and bar: ${c+i-r} pixels`),t.position.x=e,t.position.y=c,t.previousPosition.x=t.position.x,t.previousPosition.y=t.position.y,t.velocity.x=0,t.velocity.y=0,t.x=t.position.x,t.y=t.position.y,t.vx=0,t.vy=0,console.log(`✅ Ball placed at (${t.position.x}, ${t.position.y})`)}else console.error("❌ Ball not found in physics engine!")}renderGameplay(){this.renderer.drawTiltingBar(this.tiltingBar);const t=this.renderer.getContext();t&&(t.fillStyle="#00ffff",t.font="10px monospace",t.textAlign="center",t.fillText("SPACE: Start | Left: A(up)/Z(down) | Right: ↑(up)/↓(down)",180,580),t.fillText("Or click and drag mouse to control",180,595))}pause(){console.log("⏸️ Pausing Circuit Breaker..."),this.gameLoop.pause()}resume(){console.log("▶️ Resuming Circuit Breaker..."),this.gameLoop.resume()}stop(){console.log("⏹️ Stopping Circuit Breaker..."),this.gameLoop.stop(),this.isRunning=!1}getGameState(){return this.gameState}isGameRunning(){return this.isRunning&&this.gameLoop.isGameLoopRunning()}}let p=null,C=null;function L(){return M(this,null,function*(){try{console.log("🚀 Circuit Breaker - Loading...");const l=document.getElementById("game-container");if(!l)throw new Error("Game container not found");l.innerHTML="";const t=document.createElement("canvas");t.id="game-canvas",t.width=360,t.height=640,l.appendChild(t),C=new B,C.init(t),p=new H,yield p.init(),p.start(),console.log("✅ Circuit Breaker loaded successfully")}catch(l){console.error("❌ Failed to load Circuit Breaker:",l),N("Failed to load game. Please refresh the page.")}})}function N(l){const t=document.getElementById("game-container");t&&(t.innerHTML=`
      <div style="text-align: center; color: #ff0066;">
        <h1>Circuit Breaker</h1>
        <p>Error: ${l}</p>
        <p>Please refresh the page to try again.</p>
      </div>
    `)}function z(){console.log("📱 Window resized")}function F(){document.hidden?(console.log("👁️ Page hidden - pausing game"),p==null||p.pause()):(console.log("👁️ Page visible - resuming game"),p==null||p.resume())}function U(){console.log("👋 Page unloading - stopping game"),p==null||p.stop()}document.readyState==="loading"?document.addEventListener("DOMContentLoaded",L):L();window.addEventListener("resize",z);document.addEventListener("visibilitychange",F);window.addEventListener("beforeunload",U);
//# sourceMappingURL=index-4d2de944.js.map
